package com.smartcourier.dao;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.JoinType;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;

import org.springframework.transaction.annotation.Transactional;

import com.clubber.facebook.db.model.Event;
import com.clubber.facebook.db.model.Location;
import com.clubber.facebook.db.model.Place;
import com.clubber.facebook.utils.FacebookFilters;
import com.clubber.facebook.utils.FacebookUtil;
import com.clubber.rest.services.EventsService.EventsSearchParams;
import com.clubber.rest.services.EventsService.PlacesSearchParams;

@Transactional
public class CustomDbService extends AbstractDbService {
	
	public static final Integer DB_FILTER_DAYS_AGO = -365 * 5;
	public static final Integer DB_FILTER_NEXT_DAYS = 365 * 10;

	@PersistenceContext
	private EntityManager entityManager;

	 public List<Event> findEvents(EventsSearchParams params) {
	        List<Event> results = new ArrayList<Event>();
	        
	        //set up the Criteria query
	        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
	        CriteriaQuery<Event> criteriaQuery = criteriaBuilder.createQuery(Event.class);
	        Root<Event> a = criteriaQuery.from(Event.class);
	        Join<Event,Place> b = a.join("place", JoinType.LEFT);
	        Join<Place,Location> c = b.join("location", JoinType.LEFT);
	        Predicate p1 = null, p2 = null;
	        
	        // Params(Event): id
	        if (params.getId() != null){
	        	Event event = (Event) super.findById(Event.class, params.getId());
	        	results.add(event);
		        return results;
	        }
	        
	        // Params(Event): start_time, end_time
	        if (params.getFromTime() != null && params.getToTime() != null){
	        	Expression<Date> eventDate = a.get("start_time");
	        	p2 = criteriaBuilder.between(eventDate, params.getFromTime(), params.getToTime());
	        	p1 = criteriaAnd(criteriaBuilder, p1, p2);
	        }
	        
	        // Params(Location): city, country
	        if (params.getCity() != null && params.getCountry() != null){
		        p1 = criteriaBuilder.equal(c.get("city"), params.getCity());
		        p2 = criteriaBuilder.equal(c.get("country"), params.getCountry());
		        p1 = criteriaBuilder.and(p1, p2);
	        }
	        
	        // Params(Location): latitude, longitude, radius_km or radius_mi
	        if (params.getLatitude() != null && params.getLongitude() != null &&
	        		(params.getRadiusKm() != null || params.getRadiusMi() != null)){
	        	
	        	Float km = params.getRadiusKm();
	        	if(params.getRadiusMi() != null){
	        		km = FacebookUtil.miToKm(params.getRadiusMi());
	        	}
	        	Float degreesLatitude = (float) (km / 110.574);
	        	Float degreesLongitude = (float) (km / 111.320 * Math.cos(params.getLatitude()));
	        	
	            final Float latitudeMin = params.getLatitude() - degreesLatitude;
	            final Float latitudeMax = params.getLatitude() + degreesLatitude;
	            final Float longitudeMin = params.getLongitude() - degreesLongitude;
	            final Float longitudeMax = params.getLongitude() + degreesLongitude;
	            
	            Expression<Float> eventLatitude = c.get("latitude");
	            Expression<Float> eventLongitude = c.get("longitude");
	            
	            // Square search
	            p2 = criteriaBuilder.between(eventLatitude, latitudeMin, latitudeMax);
	        	p1 = criteriaAnd(criteriaBuilder, p1, p2);
	        	p2 = criteriaBuilder.between(eventLongitude, longitudeMin, longitudeMax);
	        	p1 = criteriaAnd(criteriaBuilder, p1, p2);
	            
	        	// Circle search
/*	            TypedQuery<Location> query = entityManager.createQuery(
	                    "SELECT l FROM Location l " +
	                    "WHERE l.distance( :latitude, :longitude) < :radius",
	                    Location.class);
	         
	                List<Location> resultList = query
	                    .setParameter("latitude", params.getLatitude())
	                    .setParameter("longitude", params.getLongitude())
	                    .setParameter("radius", radius)
	                    .getResultList();
	            
	                resultList.get(0);*/
	            
	           /* Expression<Double> eventDistance = criteriaBuilder.function("distance", Double.class, criteriaBuilder.literal(params.getLatitude()), criteriaBuilder.literal(params.getLongitude()));
	            
	            p2 = criteriaBuilder.lessThan(eventDistance, Double.parseDouble(radius.toString()));
	        	p1 = criteriaAnd(criteriaBuilder, p1, p2);*/
	        }
	        
	        // TODO
	        // Params: category
	        // Params: age
	        // Params: music_genre
	        // Params: other
	        
	        criteriaQuery.where(p1);
	        TypedQuery<Event> q = entityManager.createQuery(criteriaQuery);
	        results = q.getResultList();
	        return results;
	 }
	 
	 public List<Place> findPlaces(PlacesSearchParams params) {
	        List<Place> results = new ArrayList<Place>();
	        
	        //set up the Criteria query
	        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
	        CriteriaQuery<Place> criteriaQuery = criteriaBuilder.createQuery(Place.class);
	        Root<Place> a = criteriaQuery.from(Place.class);
	        Join<Place,Location> b = a.join("location", JoinType.LEFT);
	        Predicate p1 = null, p2 = null;
	        
	        // Params(Place): id
	        if (params.getId() != null){
	        	Place place = (Place) super.findById(Place.class, params.getId());
	        	results.add(place);
		        return results;
	        }
	        
	        // Params(Location): city, country
	        if (params.getCity() != null && params.getCountry() != null){
		        p1 = criteriaBuilder.equal(b.get("city"), params.getCity());
		        p2 = criteriaBuilder.equal(b.get("country"), params.getCountry());
		        p1 = criteriaBuilder.and(p1, p2);
	        }
	        
	        // Params(Location): latitude, longitude, radius_km or radius_mi
	        if (params.getLatitude() != null && params.getLongitude() != null &&
	        		(params.getRadiusKm() != null || params.getRadiusMi() != null)){
	        	
	        	Float km = params.getRadiusKm();
	        	if(params.getRadiusMi() != null){
	        		km = FacebookUtil.miToKm(params.getRadiusMi());
	        	}
	        	Float degreesLatitude = (float) (km / 110.574);
	        	Float degreesLongitude = (float) (km / 111.320 * Math.cos(params.getLatitude()));
	        	
	            final Float latitudeMin = params.getLatitude() - degreesLatitude;
	            final Float latitudeMax = params.getLatitude() + degreesLatitude;
	            final Float longitudeMin = params.getLongitude() - degreesLongitude;
	            final Float longitudeMax = params.getLongitude() + degreesLongitude;
	            
	            Expression<Float> eventLatitude = b.get("latitude");
	            Expression<Float> eventLongitude = b.get("longitude");
	            
	            // Square search
	            p2 = criteriaBuilder.between(eventLatitude, latitudeMin, latitudeMax);
	        	p1 = criteriaAnd(criteriaBuilder, p1, p2);
	        	p2 = criteriaBuilder.between(eventLongitude, longitudeMin, longitudeMax);
	        	p1 = criteriaAnd(criteriaBuilder, p1, p2);
	            
	        	// Circle search
	        }
	        
	        // Params: category
	        // Params: age
	        // Params: music_genre
	        // Params: other
	        
	        criteriaQuery.where(p1);
	        TypedQuery<Place> q = entityManager.createQuery(criteriaQuery);
	        results = q.getResultList();
	        return results;
	 }
	 
	// TODO
	// Delete filtered by global HARD-CODED properties currentDate - DB_FILTER_FROM_DAYS / currentDate + DB_FILTER_TO_DAYS
	// TODO - servlet check every day
	 public Boolean deleteOldEvents() {
		return true;
	}

	private Predicate criteriaAnd(CriteriaBuilder criteriaBuilder, Predicate p1, Predicate p2) {
		if (p1 != null){
			p1 = criteriaBuilder.and(p1, p2);
		} else{
			p1 = p2;
		}
		return p1;
	}
	
	public Boolean addNewEvent(Event event) {
		if(entityManager.find(event.getClass(), event.getId()) == null){
			if(FacebookFilters.isEntityNew(event)){
				entityManager.persist(event);
			}
			return true;
		}
		return false;
	}
	
	public ArrayList<Place> addNewEvents(List<Event> events) {
		ArrayList<Place> newPlaces = new ArrayList<Place>();
		for(Event event : events){
			if(addNewEvent(event) && event.getPlace() != null){
				newPlaces.add(event.getPlace());
			}
		}
		
		return newPlaces;
	}

/*	 public List<Event> findEventsByCity(String city) {
	        List<Event> results;
	        
	        //set up the Criteria query
	        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
	        CriteriaQuery<Event> criteriaQuery = criteriaBuilder.createQuery(Event.class);
	        Root<Event> a = criteriaQuery.from(Event.class);
	        Join<Event,Place> b = a.join("place", JoinType.LEFT);
	        Join<Place,Location> c = b.join("location", JoinType.LEFT);
	        criteriaQuery.where(criteriaBuilder.and(criteriaBuilder.equal(c.get("city"), city)));
	        TypedQuery<Event> q = entityManager.createQuery(criteriaQuery);
	   	 
	        results = q.getResultList();
	        return results;
	}*/
	
/*	 public List<Event> findEventsByPlaceName(Class<? extends DbEntity> entityClass,Map<String, String> attributes) {
	        List<Event> results;
	        
	        //set up the Criteria query
	        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
	        CriteriaQuery<Event> criteriaQuery = criteriaBuilder.createQuery(Event.class);
	        Root<Event> a = criteriaQuery.from(Event.class);
	        Join<Event,Place> b = a.join("place", JoinType.LEFT);
	        criteriaQuery.where(criteriaBuilder.and(criteriaBuilder.equal(b.get("name"), attributes.get("name"))));
	        TypedQuery<Event> q = entityManager.createQuery(criteriaQuery);
	   	 
	        results = q.getResultList();
	        return results;
    }*/
	
/*	public List<? extends DbEntity> findByLocation(Class<? extends DbEntity> entity, Float latitude, Float longitude, Double radiusInKm) {
		List<? extends DbEntity> entitiesList = entityManager.createQuery("select e from Location e").getResultList();
		return entitiesList;
	}*/
	
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	
	// Examples
	/*
	 * public Boolean addEvent(Event event) { //String success =
	 * 
	 * 
	 * // entityManager.merge(event); // return event; }
	 */

	/*
	 * public List findExecutingChangePlans() { Query query =
	 * entityManager.createQuery(
	 * "SELECT plan FROM ChangePlan plan where plan.state = 'EXECUTING'");
	 * return (List) query.getResultList(); }
	 */

	/*
	 * public Car updateCarImage(Integer dealNumber, byte[] bs) { Car car =
	 * entityManager.find(Car.class, dealNumber); if (car == null){ car = new
	 * Car(); car.setDealNumber(dealNumber); } CarImage carImage = new
	 * CarImage(); carImage.setImage(bs); car.getImages().add(carImage);
	 * entityManager.merge(car);
	 * 
	 * return car; }
	 * 
	 * public void deleteCarImage(Integer dealNumber, Long imageId) { Car car =
	 * entityManager.find(Car.class, dealNumber); if (car == null){ return; }
	 * 
	 * List<CarImage> carImages = car.getImages(); for (CarImage image :
	 * carImages){ if (image.getId() == imageId){ carImages.remove(image);
	 * break; } }
	 * 
	 * if (carImages.isEmpty()){ entityManager.remove(car); } else {
	 * entityManager.merge(car); } CarImage carImage =
	 * entityManager.find(CarImage.class, imageId);
	 * entityManager.remove(carImage); }
	 */
}